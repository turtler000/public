# mysql

## 索引 

#### Myisam

叶子节点存的物理地址

### innodb

**一定要有主键，主键为聚簇索引**

数据文件本身为索引文件，主键建立的聚簇索引

B - 树，都是左大右小，

B + 树，两个节点之间有指针，子节点带指针左边的key，只有叶子节点带数据，叶子节点存放的完整数据

优化：B+树叶子节点有指针

select * from table where name =张三"
先到name的索引里去找，找到张三对应的叶子节点，叶子节点的data就是那一行的主键，id=15，然后再根据id=15，到数据文件里面的聚簇索引根据主键组织的索引根据 id=15去定位出来id=15这一行的完整的数据

为啥innodb下不要用uuID生成的超长字符串作为主键?因为这么玩儿会导致所有的索引的data都是那个主键值，最终导致索引会变得过大，浪费很多磁盘空间。

一般innodb,表里，建议统一用auto_increment自增值作为主键值，因为这样可以保持聚簇索引直接加记录就可以，如果用那种不是单调递增的主键值，可能会导致b+树分裂后重新组织，会浪费时间。

### 联合索引

create index (A,B,C)

**全列匹配**
正好where条件里就用了这3个字段，那么就一定可以到这个联合索引的
**最左前缀匹配**
这个就是说，如果你的sql里，正好就用到了联合索引最左边的一个或者几个列表，那么也可以用上这个索引，在索引里查找的时候就用最左边的几个列就行了
select * from product where A=1 and B=1，这个是没问题的，可以用上这个索引的

**中间某个值没匹配：**

这个是说，如果你的sql里，就用了联合索引的第一个列和第三个列，那么**会按照第一个列值在索引里找，找完以后对结果集扫描一遍根据第三个列来过滤,第三个列是不走索引去搜索的,就是有一个额外的过滤的工作，但是还能用到索引，所以也还好。

select * from product where A=1 and C='2018-01-01 10:00:00‘（中间B没有）

**没有最左前缀匹配**
一定不会用索引
select  from product where B=1

**前缀匹配**

这个就是说,如果你不是等值的,比如=, >=,<=的操作,是like操作,那么必须要是like 'XX%"这种才可以用上索引，%放后边
select * from product where A=1 and B=1 and Clike "2018%'

**范围列匹配**
如果你是范围查询，比如>=,<= , between操作，你只能是符合最左前缀的规则才可以范围，范围之后的列就不用索引了
select  from product wherehop_id>=1 and B=1
这里就在联合索引中根据 A来查询了

**包含函数**
如果你对某个列用了函数，比如substring,之类的东西，那么那一列不用索引
select * from product where A=1 and 函类(B) = 2
上面就根据A在联合索引中查询

### 优缺点

耗费磁盘空间，控制数量，两三个差不多了

字段重复度高的不要加

## 事务

### ACID

原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

一致性（Consistency）：执行事务前后，保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态。多个事务对同一个数据读取的结果是相同的。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。

### 隔离级别

串行（Serializable）：彻底串行

读未提交（Read uncommitted）：还没读出来，数据被别的事务修改了

读已提交/不可重复读（Read committed）：单次事务读两次，两次读的不一样，两次读中被别的事务修改了

可重复读（Repeatable read）：每次读到某一行都是一样的，但会有幻读（Phantom read），两次读到中间被别的事务插入数据了，读到行数变多了。

对应问题：

丢失修改（Lost to modify）

脏读（Dirty read）：一个事务读取到另外一个事务未提交的数据.

不可重复读（Unrepeatableread）:当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据

幻读（Phantom read）：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。

**mysql默认的隔离级别：可重复读（Repeatable read）**

### MVCC 多版本并发控制

innodb,存储引擎，会在每行数据的最后加两个隐藏列，一个保存行的创建时间，一个保存行的删除时间，但是这儿存放的不是时间，而是事务id，事务 id是mysal自己维护的自增的，全局唯一。

InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.

行的删除版本要么未定义,要么大于当前事务版本号(这可以确保事务读取到的行，在事务开始之前未被删除)，

删除事务，更新删除时间的事务id，不影响创建时间，所以能查到。

修改事务，先插入一行，创建时间为当前事务id，之前那一行创建事务id不变。

为什么MVCC不能解决幻读？试想下边情况

事务一： read,update where id = 1,read

事务二：在第一次read后insert id = 1

事务一的update时会覆盖事务二的insert中的创建时间（其实是把事务二的insert 加了删除时间然后又insert 了），这时第二次read就会读到insert。当然读到的数据是自己update后的数据，但是这行数据本身应该不存在。

## 锁

##### 行锁（共享锁排他锁）

innodb的行锁有共享锁(S）和排他锁（x)，两种，其实说白了呢，共享锁就是，多个事务都可以加共享锁读同一行数据，获准共享锁的事务只能读数据，不能修改数据。排他锁，就是只有一个事务可以读写这行数据，别的事务只能读。
insert、 update、delete、innodb会自动给那一行加行级排他锁

innodb不会自动加共享锁，select，innodb啥锁都不加，因为 innodb大家记得么，默认实现了可重复读，也就是mvcc机制，所以多个事务随便读一个数据，一般不会有冲突，大家就读自己那个快照就可以了，不涉及到什么锁的问题

手动加共享锁: select * from table where id=1 lock in share mode，那你就给那一行加了个享锁,其他事务就不能来修改这行数据了
手动加排他锁: select * from table where id=1 for update，那你就给那一行加了个排他锁,思就是你准备修改，别的事务就别修改了，别的事务的修改会 hang住。这个要慎用，我们线上系统不用这个，容易搞出问题来。

##### 悲观锁乐观锁

乐观锁CAS ,先查，改完再比

悲观锁，select ... for update

##### 死锁

之前用liquibase死锁了

### 优化

MySQL 使用 explain + sql 查看 执行计划。

table | type | possible_keys | key | key_len | ref | rows |Extra
table:哪个表
type:这个很重要，是说类型, all (全表扫描)，const《读常量，最多一条记录匹配), sg_ref(走主键，一般就最多一条记录匹配)，index(扫描全部索引)，range(扫描部分索引)
possible_keys:显示可能使用的索引
key:实际使用的索引
key_len:使用索引的长度ref:联合索引的哪一列被用了rows:一共扫描和返回了多少行
extra: using filesort（需要额外进行排序)，using temporary ( mysal构建了临时表，比如排序的时候)，using where(就是对索引扫出来的数据再次根据where来过滤出了结果)

