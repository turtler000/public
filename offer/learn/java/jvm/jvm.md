# jvm

## 1、内存模型

爬了，搞这么多遍也背不下来

### 原子性，有序性，可见性

##### 可见性：一个线程修改了共享变量的值，其他线程也能看到最新修改的值 。

**原子性**：操作是不可中断的，要么全部执行成功要么全部执行失败

**有序性**：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。指令重排

### happes-before 

保证可见性，禁止指令重排

happens before 原则：特殊情况下不允许编译器指令器重排，保证代码有序性

1、程序次序规则:一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作

2、锁定规则:一个unLock操作先行发生于后面对同一个锁的lock操作，比如说在代码里有先对一个lock.loclock.unlock()，lock.lock()，

3、volatile变量规则:对一个volatile变量的写操作先行发生于后面对这个volatile变量的读操作，volatile变量写，再是读，必须保证是先写，再读

4、传递规则:如果操作A先行发生于操作B，而操作B又先行发生于操作c，则可以得出操作A先行发生于操作

5、线程启动规则:Thread对象的start()方法先行发生于此线程的每个一个动作, thread.start()，thread.interrupt()，

6、线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

7、线程终结规则:线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行工

8、对象终结规则:一个对象的初始化完成先行发生于他的finalize()方法的开始

### volatile

volatile可以保证可见性，有序性，但是不能保证原子性

怎么保证原子性：加锁，synchronized，lock

内存屏障：各种屏障

(1) lock指令: volatile保证可见性

对volatile 修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写回主内存，同时因为有MESl缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改

如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了'

lock前缀指令+MESI缓存一致性协议

### GC垃圾回收

1、年轻代

HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。

2、stop the world

垃圾回收时停止所有代码和线程，扫描对象，判断回收

### 进程间通信

信号量，管道，socket

### IO

同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。

- Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
- Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
- Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，

### 线上问题

1.线上cpu 100%

先用top看线程，然后jstack 进程号|grep 线程号

就打印代码了

2.线上进程kill不掉

ps -aux 看状态，为z的是zombie进程

ps -ef kill父进程

3.磁盘满了

df -h    看目录大小

find /-size 100m+       看文件大小

写个脚本定期删日志



